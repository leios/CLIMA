<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TurbulenceConvection · CLIMA</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.svg" alt="CLIMA logo"/></a><h1>CLIMA</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Common</span><ul><li><a class="toctext" href="../Common/MoistThermodynamics.html">MoistThermodynamics</a></li></ul></li><li><span class="toctext">Utilites</span><ul><li><a class="toctext" href="../Utilities/RootSolvers.html">RootSolvers</a></li></ul></li><li><span class="toctext">Atmos</span><ul><li><a class="toctext" href="SurfaceFluxes.html"><code>SurfaceFluxes</code></a></li><li class="current"><a class="toctext" href="TurbulenceConvection.html"><code>TurbulenceConvection</code></a><ul class="internal"><li><a class="toctext" href="#Grids-1">Grids</a></li><li><a class="toctext" href="#Grid-Operators-1">Grid Operators</a></li><li><a class="toctext" href="#State-Vector-1">State Vector</a></li><li><a class="toctext" href="#Boundary-Conditions-1">Boundary Conditions</a></li><li><a class="toctext" href="#State-Vector-Functions-1">State Vector Functions</a></li><li><a class="toctext" href="#Solving-a-diffusion-equation-1">Solving a diffusion equation</a></li><li><a class="toctext" href="#Solving-a-diffusion-equation-Neumann-BCs-Top-1">Solving a diffusion equation Neumann BCs Top</a></li><li><a class="toctext" href="#Solving-a-diffusion-equation-Neumann-BCs-Bottom-1">Solving a diffusion equation Neumann BCs Bottom</a></li><li><a class="toctext" href="#Solving-a-variable-coefficient-diffusion-equation-1">Solving a variable coefficient diffusion equation</a></li><li><a class="toctext" href="#Solving-a-linear-advection-equation-1">Solving a linear advection equation</a></li><li><a class="toctext" href="#Solving-a-non-linear-advection-equation-conservative-form-1">Solving a non-linear advection equation conservative form</a></li></ul></li><li><a class="toctext" href="EDMFEquations.html">Eddy-Diffusivity Mass-Flux (EDMF) equations</a></li><li><a class="toctext" href="Microphysics.html">Microphysics</a></li></ul></li><li><a class="toctext" href="../ODESolvers.html">ODESolvers</a></li><li><a class="toctext" href="../LinearSolvers.html">LinearSolvers</a></li><li><a class="toctext" href="../Mesh.html">Mesh</a></li><li><a class="toctext" href="../Arrays.html">Arrays</a></li><li><a class="toctext" href="../DGmethods_old.html">DGmethods_old</a></li><li><a class="toctext" href="../InputOutput.html">InputOutput</a></li><li><span class="toctext">Developer docs</span><ul><li><a class="toctext" href="../CodingConventions.html">Coding Conventions</a></li><li><a class="toctext" href="../AcceptableUnicode.html">Acceptable Unicode characters</a></li><li><a class="toctext" href="../VariableList.html">CliMA Variable List</a></li></ul></li><li><span class="toctext">Balance Law Examples</span><ul><li><a class="toctext" href="../BalanceLawOverview.html">DG Balance Law Method</a></li><li><a class="toctext" href="../examples/DGmethods_old/generated/ex_001_periodic_advection.html">Example 001: Periodic Advection</a></li><li><a class="toctext" href="../examples/DGmethods_old/generated/ex_002_solid_body_rotation.html">Example 002: Solid Body Rotation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Atmos</li><li><a href="TurbulenceConvection.html"><code>TurbulenceConvection</code></a></li></ul><a class="edit-page" href="https://github.com/climate-machine/CLIMA/blob/master/docs/src/Atmos/TurbulenceConvection.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TurbulenceConvection</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TurbulenceConvection-1" href="#TurbulenceConvection-1"><code>TurbulenceConvection</code></a></h1><h2><a class="nav-anchor" id="Grids-1" href="#Grids-1">Grids</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.Grids.Grid" href="#CLIMA.TurbulenceConvection.Grids.Grid"><code>CLIMA.TurbulenceConvection.Grids.Grid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Grid{T}</code></pre><p>A simple 1-dimensional uniform grid of type <code>T</code> for finite difference method.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/Grids.jl#L12-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.Grids.over_elems" href="#CLIMA.TurbulenceConvection.Grids.over_elems"><code>CLIMA.TurbulenceConvection.Grids.over_elems</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">over_elems(grid::Grid)</code></pre><p>Get the range of indexes to traverse real and ghost grid elements</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/Grids.jl#L109-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.Grids.over_elems_real" href="#CLIMA.TurbulenceConvection.Grids.over_elems_real"><code>CLIMA.TurbulenceConvection.Grids.over_elems_real</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">over_elems_real(grid::Grid)</code></pre><p>Get the range of indexes to traverse only real grid elements</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/Grids.jl#L116-L120">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.Grids.over_elems_ghost" href="#CLIMA.TurbulenceConvection.Grids.over_elems_ghost"><code>CLIMA.TurbulenceConvection.Grids.over_elems_ghost</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">over_elems_ghost(grid::Grid)</code></pre><p>Get the range of indexes to traverse only ghost grid elements</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/Grids.jl#L123-L127">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.Grids.first_elem_above_surface" href="#CLIMA.TurbulenceConvection.Grids.first_elem_above_surface"><code>CLIMA.TurbulenceConvection.Grids.first_elem_above_surface</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">first_elem_above_surface(grid::Grid)</code></pre><p>Get the first element index above the surface</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/Grids.jl#L130-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.Grids.get_z" href="#CLIMA.TurbulenceConvection.Grids.get_z"><code>CLIMA.TurbulenceConvection.Grids.get_z</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get_z(grid::Grid, k::Int)</code></pre><p>Get the z-coordinate given element index</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/Grids.jl#L102-L106">source</a></section><h2><a class="nav-anchor" id="Grid-Operators-1" href="#Grid-Operators-1">Grid Operators</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.GridOperators.∇_z" href="#CLIMA.TurbulenceConvection.GridOperators.∇_z"><code>CLIMA.TurbulenceConvection.GridOperators.∇_z</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">∇_z(f, grid::Grid)</code></pre><p>Computes the local derivative of field <span>$f$</span>: <span>$∇f$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/GridOperators.jl#L12-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.GridOperators.Δ_z" href="#CLIMA.TurbulenceConvection.GridOperators.Δ_z"><code>CLIMA.TurbulenceConvection.GridOperators.Δ_z</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Δ_z(f, grid::Grid)</code></pre><p>Computes the local Laplacian of field <span>$f$</span>: <span>$∇ • (∇f)$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/GridOperators.jl#L20-L25">source</a><div><div><pre><code class="language-none">Δ_z(f, grid::Grid, K)</code></pre><p>Computes the local Laplacian of field <span>$f$</span> with a variable coefficient: <span>$∇ • (K ∇f)$</span></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/GridOperators.jl#L28-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.GridOperators.adv_upwind" href="#CLIMA.TurbulenceConvection.GridOperators.adv_upwind"><code>CLIMA.TurbulenceConvection.GridOperators.adv_upwind</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">adv_upwind(ϕ, w, grid::Grid)</code></pre><p>Local upwind advection operator <span>$w • ∇ϕ$</span>. This operator is stable but numerically diffusive.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/Grids/GridOperators.jl#L41-L46">source</a></section><h2><a class="nav-anchor" id="State-Vector-1" href="#State-Vector-1">State Vector</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecs.StateVec" href="#CLIMA.TurbulenceConvection.StateVecs.StateVec"><code>CLIMA.TurbulenceConvection.StateVecs.StateVec</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StateVec{T, I, NT}</code></pre><p>A state vector containing the number of subdomains, <code>n_subdomains</code>, a <code>NamedTuple</code> variable mapper, a tuple of the variable names, and a vector of vectors, containing the values for all of the variables.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecs.jl#L16-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecs.over_sub_domains" href="#CLIMA.TurbulenceConvection.StateVecs.over_sub_domains"><code>CLIMA.TurbulenceConvection.StateVecs.over_sub_domains</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">over_sub_domains(state_vec::StateVec)</code></pre><p>Get list of indexes from 1 to the maximum subdomain size.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecs.jl#L95-L99">source</a><div><div><pre><code class="language-none">over_sub_domains(state_vec::StateVec, j::Int)</code></pre><p>Get list of indexes from 1 to the maximum subdomain size, except the given index.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecs.jl#L102-L106">source</a><div><div><pre><code class="language-none">over_sub_domains(state_vec::StateVec, name::Symbol)</code></pre><p>Get list of indexes over all subdomains for variable <code>name</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecs.jl#L109-L113">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecs.Cut" href="#CLIMA.TurbulenceConvection.StateVecs.Cut"><code>CLIMA.TurbulenceConvection.StateVecs.Cut</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Cut{I} &lt;: AbstractCut{I}</code></pre><p>A Cut struct used to slice the state vector along the grid-element dimension. This is used to as an API to pass Cuts into local derivative/interpolation routines.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecs.jl#L124-L131">source</a></section><h2><a class="nav-anchor" id="Boundary-Conditions-1" href="#Boundary-Conditions-1">Boundary Conditions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.BoundaryConditions.Dirichlet!" href="#CLIMA.TurbulenceConvection.BoundaryConditions.Dirichlet!"><code>CLIMA.TurbulenceConvection.BoundaryConditions.Dirichlet!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Dirichlet!(sv::StateVec, name::Symbol, val, grid, ::Bottom, i_sd=1)</code></pre><p>Apply Dirichlet boundary conditions at the bottom of the domain</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/BoundaryConditions.jl#L28-L32">source</a><div><div><pre><code class="language-none">Dirichlet!(sv::StateVec, name::Symbol, val, grid, ::Top, i_sd=1)</code></pre><p>Apply Dirichlet boundary conditions at the bottom of the domain</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/BoundaryConditions.jl#L38-L42">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.BoundaryConditions.Neumann!" href="#CLIMA.TurbulenceConvection.BoundaryConditions.Neumann!"><code>CLIMA.TurbulenceConvection.BoundaryConditions.Neumann!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">Neumann!(sv::StateVec, name::Symbol, val, grid, ::Bottom, i_sd=1)</code></pre><p>Apply Neumann boundary conditions at the bottom of the domain.</p><pre><code class="language-none">∇u = g n̂</code></pre><p>Where <code>n̂</code> is the outward facing normal and <code>u</code> is the variable <code>name</code> in <code>sv</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/BoundaryConditions.jl#L48-L56">source</a><div><div><pre><code class="language-none">Neumann!(sv::StateVec, name::Symbol, val, grid, ::Top, i_sd=1)</code></pre><p>Apply Neumann boundary conditions at the bottom of the domain</p><pre><code class="language-none">∇u = g n̂</code></pre><p>Where <code>n̂</code> is the outward facing normal and <code>u</code> is the variable <code>name</code> in <code>sv</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/BoundaryConditions.jl#L62-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.BoundaryConditions.Top" href="#CLIMA.TurbulenceConvection.BoundaryConditions.Top"><code>CLIMA.TurbulenceConvection.BoundaryConditions.Top</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Top&lt;:BoundaryLocation</code></pre><p>Location to apply boundary condition</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/BoundaryConditions.jl#L14-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.BoundaryConditions.Bottom" href="#CLIMA.TurbulenceConvection.BoundaryConditions.Bottom"><code>CLIMA.TurbulenceConvection.BoundaryConditions.Bottom</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Bottom&lt;:BoundaryLocation</code></pre><p>Location to apply boundary condition</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/BoundaryConditions.jl#L21-L25">source</a></section><h2><a class="nav-anchor" id="State-Vector-Functions-1" href="#State-Vector-Functions-1">State Vector Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.first_elem_above_surface_val" href="#CLIMA.TurbulenceConvection.StateVecFuncs.first_elem_above_surface_val"><code>CLIMA.TurbulenceConvection.StateVecFuncs.first_elem_above_surface_val</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">first_elem_above_surface_val(sv::StateVec, name::Symbol, grid::Grid, i_sd=1)</code></pre><p>Get the value of variable <code>name</code> on the first element above the surface (<code>z_min+Δz/2</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L31-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.surface_val" href="#CLIMA.TurbulenceConvection.StateVecFuncs.surface_val"><code>CLIMA.TurbulenceConvection.StateVecFuncs.surface_val</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">surface_val(sv::StateVec, name::Symbol, grid::Grid, i_sd=1)</code></pre><p>Get the value of variable <code>name</code> on the surface (<code>z_min</code>) by interpolating between the first ghost point and the first element above the surface</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L20-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.extrap!" href="#CLIMA.TurbulenceConvection.StateVecFuncs.extrap!"><code>CLIMA.TurbulenceConvection.StateVecFuncs.extrap!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">extrap!(sv::StateVec, name::Symbol, grid::Grid, i_sd=1)</code></pre><p>Extrapolate variable <code>name</code> to the first ghost point.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L134-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.assign_ghost!" href="#CLIMA.TurbulenceConvection.StateVecFuncs.assign_ghost!"><code>CLIMA.TurbulenceConvection.StateVecFuncs.assign_ghost!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">assign_ghost!(sv::StateVec, name::Symbol, val, grid::Grid, i_sd=1)</code></pre><p>Assign value <code>val</code> to variable <code>name</code> for all ghost points.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L146-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.domain_average!" href="#CLIMA.TurbulenceConvection.StateVecFuncs.domain_average!"><code>CLIMA.TurbulenceConvection.StateVecFuncs.domain_average!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">domain_average!(dst::StateVec, src::StateVec, weight::StateVec
                dst_idxs, src_idxs, weight_idx, grid::Grid)</code></pre><p>Compute the domain average in state vector <code>dst</code>, given state vectors <code>src</code> and <code>weight</code>, the grid <code>grid</code> and index iterators of source, destination and weight names <code>src_idxs</code>, <code>dst_idxs</code>, and <code>weight_idx</code> respectively.</p><p>Formulaically, a domain-averaged variable <span>$⟨ϕ⟩$</span> is computed from</p><p><span>$⟨ϕ⟩ = Σ_i a_i \overline{ϕ}_i$</span></p><p>Where variable <span>$\overline{ϕ}_i$</span> represents <span>$ϕ$</span> decomposed across multiple sub-domains, which are weighted by area fractions <span>$a_i$</span>.</p><p>Note that <code>domain_average!</code> is the inverse function of <code>distribute!</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L41-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.distribute!" href="#CLIMA.TurbulenceConvection.StateVecFuncs.distribute!"><code>CLIMA.TurbulenceConvection.StateVecFuncs.distribute!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">distribute!(dst::StateVec, src::StateVec, dst_idxs, src_idxs, grid::Grid)</code></pre><p>Distributes values in the state vector <code>src</code>, to state vectors <code>dst</code> given the grid <code>grid</code> and index iterators of source and destination names <code>src_idxs</code> and <code>dst_idxs</code> respectively.</p><p>Formulaically, a domain-decomposed variable <span>$\overline{ϕ}_i$</span> is computed from</p><p><span>$\overline{ϕ}_i = ⟨ϕ⟩$</span></p><p>Where variable <span>$⟨ϕ⟩$</span> is the domain-averaged variable, computed across multiple sub-domains.</p><p>Note that <code>distribute!</code> is the inverse function of <code>domain_average!</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L70-L85">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.total_covariance!" href="#CLIMA.TurbulenceConvection.StateVecFuncs.total_covariance!"><code>CLIMA.TurbulenceConvection.StateVecFuncs.total_covariance!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">total_covariance!(dst::StateVec, src::StateVec, cv::StateVec, weights::StateVec,
                  dst_idxs, src_idxs, cv_idxs, weight_idx,
                  grid::Grid, decompose_ϕ_ψ::Function)</code></pre><p>Computes the total covariance in state vector <code>dst</code>, given</p><ul><li><code>src</code> source state vector</li><li><code>cv</code> state vector containing co-variances</li><li><code>weights</code> state vector containing weights</li><li><code>dst_idxs</code> indexes for destination state vector</li><li><code>cv_idxs</code> indexes for state vector containing co-variances</li><li><code>weight_idx</code> indexes for state vector containing weights</li><li><code>grid</code> the grid</li><li><code>decompose_ϕ_ψ</code> a function that receives the covariance index and                 returns the indexes for each variable. For example:                 <code>:ϕ_idx, :ψ_idx = decompose_ϕ_ψ(:cv_ϕ_ψ)</code></li></ul><p>Formulaically, a total covariance between variables <span>$ϕ$</span> and <span>$ψ$</span> is computed from</p><p><span>$⟨ϕ^*ψ^*⟩ = Σ_i a_i \overline{ϕ_i&#39;ψ_i&#39;} + Σ_i Σ_j a_i a_j \overline{ϕ}_i (\overline{ψ}_i - \overline{ψ}_j)$</span></p><p>Where variable <span>$\overline{ϕ}_i$</span> represents <span>$ϕ$</span> decomposed across multiple sub-domains, which are weighted by area fractions <span>$a_i$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L94-L117">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.TurbulenceConvection.StateVecFuncs.export_state" href="#CLIMA.TurbulenceConvection.StateVecFuncs.export_state"><code>CLIMA.TurbulenceConvection.StateVecFuncs.export_state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">export_state(sv::StateVec, grid::Grid, dir, filename, ::ExportType)</code></pre><p>Export StateVec to a human-readable file <code>filename</code> in directory <code>dir</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L219-L223">source</a><div><div><pre><code class="language-none">export_state(sv::StateVec, dir, filename, ::ExportType = UseDat())</code></pre><p>Export StateVec to a human-readable file <code>filename</code> in directory <code>dir</code>. The <code>z</code>-axis is <em>not</em> included in the export.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L240-L245">source</a><div><div><pre><code class="language-none">export_state(sv::StateVec, grid::Grid, dir, filename, ::UseVTK)</code></pre><p>Export state vector <code>sv</code> to a compressed file <code>filename</code> in directory <code>dir</code>, including the <code>z</code>-axis, given by the grid <code>grid</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Atmos/Parameterizations/TurbulenceConvection/StateVecs/StateVecFuncs.jl#L252-L257">source</a></section><h2><a class="nav-anchor" id="Solving-a-diffusion-equation-1" href="#Solving-a-diffusion-equation-1">Solving a diffusion equation</a></h2><p>Here, we solve a simple diffusion equation</p><p><span>$∂_t T = K ΔT + 1, \qquad T = 0 ∈ ∂Ω$</span></p><p>using Explicit Euler with <code>StateVec</code> and <code>Grid</code> constructs.</p><pre><code class="language-julia">using CLIMA.TurbulenceConvection.Grids
using CLIMA.TurbulenceConvection.GridOperators
using CLIMA.TurbulenceConvection.BoundaryConditions
using CLIMA.TurbulenceConvection.StateVecs
using CLIMA.TurbulenceConvection.StateVecFuncs
using Plots

n_sd = 1 # number of sub-domains
K = 1.0 # diffusion coefficient
maxiter = 1000 # time-step iterations
Δt = 0.001 # time step

grid = Grid(0.0, 1.0, 10)
q = StateVec(((:T, n_sd),), grid)
rhs = deepcopy(q)

for i in 1:maxiter
  for k in over_elems_real(grid)
    rhs[:T, k] = K*Δ_z(q[:T, Cut(k)], grid) + 1
  end
  for k in over_elems(grid)
    q[:T, k] += Δt*rhs[:T, k]
  end
  Dirichlet!(q, :T, 0.0, grid, Top())
  Dirichlet!(q, :T, 0.0, grid, Bottom())
end
plot_state(q, grid, &quot;./&quot;, &quot;T.svg&quot;, :T) # for visualizing</code></pre><pre><code class="language-none">/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="T.svg" alt/></p><h2><a class="nav-anchor" id="Solving-a-diffusion-equation-Neumann-BCs-Top-1" href="#Solving-a-diffusion-equation-Neumann-BCs-Top-1">Solving a diffusion equation Neumann BCs Top</a></h2><p>Here, we solve a simple diffusion equation</p><p><span>$∂_t T = K ΔT, \qquad ∂_z T = 1 ∈ z_{min}, T = 0 ∈ z_{max}$</span></p><p>using Explicit Euler with <code>StateVec</code> and <code>Grid</code> constructs.</p><pre><code class="language-julia">using CLIMA.TurbulenceConvection.Grids
using CLIMA.TurbulenceConvection.GridOperators
using CLIMA.TurbulenceConvection.BoundaryConditions
using CLIMA.TurbulenceConvection.StateVecs
using CLIMA.TurbulenceConvection.StateVecFuncs
using Plots

n_sd = 1 # number of sub-domains
K = 1.0 # diffusion coefficient
maxiter = 200 # time-step iterations
Δt = 0.001 # time step

grid = Grid(0.0, 1.0, 10)
q = StateVec(((:T, n_sd),), grid)
rhs = deepcopy(q)

for i in 1:maxiter
  for k in over_elems_real(grid)
    rhs[:T, k] = K*Δ_z(q[:T, Cut(k)], grid)
  end
  for k in over_elems(grid)
    q[:T, k] += Δt*rhs[:T, k]
  end
  q_flux = 1 # Leaving domain
  q_bc = -q_flux/K
  Neumann!(q, :T, q_bc, grid, Top())
  Dirichlet!(q, :T, 0.0, grid, Bottom())
end
plot_state(q, grid, &quot;./&quot;, &quot;T_NeumannTop.svg&quot;, :T) # for visualizing</code></pre><pre><code class="language-none">/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="T_NeumannTop.svg" alt/></p><h2><a class="nav-anchor" id="Solving-a-diffusion-equation-Neumann-BCs-Bottom-1" href="#Solving-a-diffusion-equation-Neumann-BCs-Bottom-1">Solving a diffusion equation Neumann BCs Bottom</a></h2><p>Here, we solve a simple diffusion equation</p><p><span>$∂_t T = K ΔT, \qquad ∂_z T = 1 ∈ z_{min}, T = 0 ∈ z_{max}$</span></p><p>using Explicit Euler with <code>StateVec</code> and <code>Grid</code> constructs.</p><pre><code class="language-julia">using CLIMA.TurbulenceConvection.Grids
using CLIMA.TurbulenceConvection.GridOperators
using CLIMA.TurbulenceConvection.BoundaryConditions
using CLIMA.TurbulenceConvection.StateVecs
using CLIMA.TurbulenceConvection.StateVecFuncs
using Plots

n_sd = 1 # number of sub-domains
K = 1.0 # diffusion coefficient
maxiter = 200 # time-step iterations
Δt = 0.001 # time step

grid = Grid(0.0, 1.0, 10)
q = StateVec(((:T, n_sd),), grid)
rhs = deepcopy(q)

for i in 1:maxiter
  for k in over_elems_real(grid)
    rhs[:T, k] = K*Δ_z(q[:T, Cut(k)], grid)
  end
  for k in over_elems(grid)
    q[:T, k] += Δt*rhs[:T, k]
  end
  Dirichlet!(q, :T, 0.0, grid, Top())

  q_flux = 1 # Entering domain
  q_bc = -q_flux/K
  Dirichlet!(q, :T, q_bc, grid, Bottom())
end
plot_state(q, grid, &quot;./&quot;, &quot;T_NeumannBot.svg&quot;, :T) # for visualizing</code></pre><pre><code class="language-none">/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="T_NeumannBot.svg" alt/></p><h2><a class="nav-anchor" id="Solving-a-variable-coefficient-diffusion-equation-1" href="#Solving-a-variable-coefficient-diffusion-equation-1">Solving a variable coefficient diffusion equation</a></h2><p>Here, we solve a variable coefficient diffusion equation</p><p><span>$∂_t T = ∇ • (K(z)∇T) + 1, \qquad T = 0 ∈ ∂Ω$</span></p><p><span>$K(z) = 1 - .9 \times H(z-.5), \qquad H = \text{heaviside}$</span></p><p>using Explicit Euler.</p><pre><code class="language-julia">using CLIMA.TurbulenceConvection.Grids
using CLIMA.TurbulenceConvection.GridOperators
using CLIMA.TurbulenceConvection.BoundaryConditions
using CLIMA.TurbulenceConvection.StateVecs
using CLIMA.TurbulenceConvection.StateVecFuncs
using Plots

n_sd = 1 # number of sub-domains
maxiter = 10000 # time-step iterations
Δt = 0.001 # time step

grid = Grid(0.0, 1.0, 10)
unknowns = ( (:T, n_sd), )
vars = ( (:ΔT, n_sd), (:K_thermal, n_sd) )
q = StateVec(unknowns, grid)
tmp = StateVec(vars, grid)
rhs = deepcopy(q)

cond_thermal(z) = z &gt; .5 ? 1 : .1
for i in 1:maxiter
  for k in over_elems_real(grid)
    tmp[:K_thermal, k] = cond_thermal(get_z(grid, k))
    tmp[:ΔT, k] = Δ_z(q[:T, Cut(k)], grid, tmp[:K_thermal, Cut(k)])
    rhs[:T, k] = tmp[:ΔT, k] + 1
  end
  for k in over_elems(grid)
    q[:T, k] += Δt*rhs[:T, k]
  end
  Dirichlet!(q, :T, 0.0, grid, Top())
  Dirichlet!(q, :T, 0.0, grid, Bottom())
end
plot_state(q, grid, &quot;./&quot;, &quot;T_varK.svg&quot;, :T) # for visualizing</code></pre><pre><code class="language-none">/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="T_varK.svg" alt/></p><h2><a class="nav-anchor" id="Solving-a-linear-advection-equation-1" href="#Solving-a-linear-advection-equation-1">Solving a linear advection equation</a></h2><p>Here, we solve a linear advection equation</p><p><span>$∂_t u + c∇u = 0, \qquad u = 0 ∈ ∂Ω$</span></p><p><span>$u(t=0) = Gaussian(σ, μ)$</span></p><p>using Explicit Euler method.</p><pre><code class="language-julia">using CLIMA.TurbulenceConvection.Grids
using CLIMA.TurbulenceConvection.GridOperators
using CLIMA.TurbulenceConvection.BoundaryConditions
using CLIMA.TurbulenceConvection.StateVecs
using CLIMA.TurbulenceConvection.StateVecFuncs
using Plots

n_sd = 1 # number of sub-domains
maxiter = 400 # time-step iterations
Δt = 0.0005 # time step

grid = Grid(0.0, 1.0, 200)
unknowns = ( (:u, n_sd), )
vars = ( (:u_initial, n_sd), )
q = StateVec(unknowns, grid)
tmp = StateVec(vars, grid)
rhs = deepcopy(q)

σ, μ, c = .05, 0.3, 1.0
T = maxiter*Δt
ic(z) = 1/(σ*sqrt(2*π))*exp(-1/2*((z-μ)/σ)^2)
for k in over_elems_real(grid)
  tmp[:u_initial, k] = ic(get_z(grid, k))
  q[:u, k] = tmp[:u_initial, k]
end
plot_state(tmp, grid, &quot;./&quot;, &quot;u_initial.svg&quot;, :u_initial) # for visualizing
for i in 1:maxiter
  for k in over_elems_real(grid)
    rhs[:u, k] = - adv_upwind(q[:u, Cut(k)], c .* [1,1,1], grid)
  end
  for k in over_elems(grid)
    q[:u, k] += Δt*rhs[:u, k]
  end
  Dirichlet!(q, :u, 0.0, grid, Top())
  Dirichlet!(q, :u, 0.0, grid, Bottom())
end
plot_state(q, grid, &quot;./&quot;, &quot;u_final.svg&quot;, :u) # for visualizing</code></pre><pre><code class="language-none">/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS
/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="u_initial.svg" alt/> <img src="u_final.svg" alt/></p><h2><a class="nav-anchor" id="Solving-a-non-linear-advection-equation-conservative-form-1" href="#Solving-a-non-linear-advection-equation-conservative-form-1">Solving a non-linear advection equation conservative form</a></h2><p>Here, we solve a non-linear advection equation</p><p><span>$∂_t u + ∇•(uu) = 0, \qquad u = 0 ∈ ∂Ω$</span></p><p><span>$u(t=0) = Gaussian(σ, μ)$</span></p><p>using Explicit Euler method.</p><pre><code class="language-julia">using CLIMA.TurbulenceConvection.Grids
using CLIMA.TurbulenceConvection.GridOperators
using CLIMA.TurbulenceConvection.BoundaryConditions
using CLIMA.TurbulenceConvection.StateVecs
using CLIMA.TurbulenceConvection.StateVecFuncs
using Plots

n_sd = 1 # number of sub-domains
maxiter = 400 # time-step iterations
Δt = 0.00001 # time step

grid = Grid(0.0, 1.0, 200)
unknowns = ( (:u, n_sd), )
vars = ( (:u_initial, n_sd), )
q = StateVec(unknowns, grid)
tmp = StateVec(vars, grid)
rhs = deepcopy(q)

σ, μ, c = .05, 0.3, 1.0
T = maxiter*Δt
ic(z) = 1/(σ*sqrt(2*π))*exp(-1/2*((z-μ)/σ)^2)
for k in over_elems_real(grid)
  tmp[:u_initial, k] = ic(get_z(grid, k))
  q[:u, k] = tmp[:u_initial, k]
end
plot_state(tmp, grid, &quot;./&quot;, &quot;u_initialNonLinear.svg&quot;, :u_initial) # for visualizing
for i in 1:maxiter
  for k in over_elems_real(grid)
    rhs[:u, k] = - adv_upwind_conservative(q[:u, Cut(k)], q[:u, Cut(k)], grid)
  end
  for k in over_elems(grid)
    q[:u, k] += Δt*rhs[:u, k]
  end
  Dirichlet!(q, :u, 0.0, grid, Top())
  Dirichlet!(q, :u, 0.0, grid, Bottom())
end
plot_state(q, grid, &quot;./&quot;, &quot;u_finalNonLinear.svg&quot;, :u) # for visualizing</code></pre><pre><code class="language-none">/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS
/home/vsts/.julia/packages/GR/TMylY/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="u_initialNonLinear.svg" alt/> <img src="u_finalNonLinear.svg" alt/></p><footer><hr/><a class="previous" href="SurfaceFluxes.html"><span class="direction">Previous</span><span class="title"><code>SurfaceFluxes</code></span></a><a class="next" href="EDMFEquations.html"><span class="direction">Next</span><span class="title">Eddy-Diffusivity Mass-Flux (EDMF) equations</span></a></footer></article></body></html>
