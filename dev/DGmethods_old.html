<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DGmethods_old · CLIMA</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="CLIMA logo"/></a><h1>CLIMA</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Utilites</span><ul><li><a class="toctext" href="Utilities/RootSolvers.html">RootSolvers</a></li><li><a class="toctext" href="Utilities/MoistThermodynamics.html">MoistThermodynamics</a></li></ul></li><li><span class="toctext">Atmos</span><ul><li><a class="toctext" href="Atmos/SurfaceFluxes.html"><code>SurfaceFluxes</code></a></li><li><a class="toctext" href="Atmos/TurbulenceConvection.html"><code>TurbulenceConvection</code></a></li><li><a class="toctext" href="Atmos/EDMFEquations.html">Eddy-Diffusivity Mass-Flux (EDMF) equations</a></li><li><a class="toctext" href="Atmos/Microphysics.html">Microphysics</a></li></ul></li><li><a class="toctext" href="ODESolvers.html">ODESolvers</a></li><li><a class="toctext" href="LinearSolvers.html">LinearSolvers</a></li><li><a class="toctext" href="Mesh.html">Mesh</a></li><li><a class="toctext" href="Arrays.html">Arrays</a></li><li class="current"><a class="toctext" href="DGmethods_old.html">DGmethods_old</a><ul class="internal"><li><a class="toctext" href="#SpaceMethods-1"><code>SpaceMethods</code></a></li><li><a class="toctext" href="#DGBalanceLawDiscretizations-1"><code>DGBalanceLawDiscretizations</code></a></li><li><a class="toctext" href="#DGBalanceLawDiscretizations.NumericalFluxes_old-1"><code>DGBalanceLawDiscretizations.NumericalFluxes_old</code></a></li></ul></li><li><a class="toctext" href="InputOutput.html">InputOutput</a></li><li><span class="toctext">Developer docs</span><ul><li><a class="toctext" href="CodingConventions.html">Coding Conventions</a></li><li><a class="toctext" href="AcceptableUnicode.html">Acceptable Unicode characters</a></li><li><a class="toctext" href="VariableList.html">CliMA Variable List</a></li></ul></li><li><span class="toctext">Balance Law Examples</span><ul><li><a class="toctext" href="BalanceLawOverview.html">DG Balance Law Method</a></li><li><a class="toctext" href="examples/DGmethods_old/generated/ex_001_periodic_advection.html">Example 001: Periodic Advection</a></li><li><a class="toctext" href="examples/DGmethods_old/generated/ex_002_solid_body_rotation.html">Example 002: Solid Body Rotation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="DGmethods_old.html">DGmethods_old</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/CLIMA/blob/master/docs/src/DGmethods_old.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>DGmethods_old</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="DGmethods_old-1" href="#DGmethods_old-1">DGmethods_old</a></h1><h2><a class="nav-anchor" id="SpaceMethods-1" href="#SpaceMethods-1"><code>SpaceMethods</code></a></h2><p>Set of abstract types for spatial discretizations</p><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.AbstractSpaceMethod" href="#CLIMA.SpaceMethods.AbstractSpaceMethod"><code>CLIMA.SpaceMethods.AbstractSpaceMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractSpaceMethod</code></pre><p>Supertype for spatial discretizations</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods/SpaceMethods.jl#L5-L9">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.AbstractDGMethod" href="#CLIMA.SpaceMethods.AbstractDGMethod"><code>CLIMA.SpaceMethods.AbstractDGMethod</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractDGMethod &lt;: AbstractSpaceMethod</code></pre><p>Supertype for discontinuous Galerkin spatial discretizations</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods/SpaceMethods.jl#L12-L16">source</a></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.SpaceMethods.odefun!" href="#CLIMA.SpaceMethods.odefun!"><code>CLIMA.SpaceMethods.odefun!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">odefun!(disc::AbstractSpaceMethod, dQ, Q, t; increment)</code></pre><p>Evaluates the right-hand side of the spatial discretization defined by <code>disc</code> at time <code>t</code> with state <code>Q</code>. The result is either added into <code>dQ</code> if <code>increment</code> is true or stored in <code>dQ</code> if it is false. Namely, the semi-discretization is of the form <span>$\dot{Q} = F(Q, t)$</span> and after the call <code>dQ += F(Q, t)</code> if <code>increment == true</code> or <code>dQ = F(Q, t)</code> if <code>increment == false</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>There is no generic implementation of this function. This must be implemented for each subtype of <code>AbstractSpaceMethod</code></p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods/SpaceMethods.jl#L19-L36">source</a></section><h2><a class="nav-anchor" id="DGBalanceLawDiscretizations-1" href="#DGBalanceLawDiscretizations-1"><code>DGBalanceLawDiscretizations</code></a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations" href="#CLIMA.DGBalanceLawDiscretizations"><code>CLIMA.DGBalanceLawDiscretizations</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>DG Balance Law Discretizations module. Attempts to provide a reasonable implementation of a discontinuous Galerkin method (in weak form) on tensor product quadrilateral (2D) and hexahedral (3D) elements for balance laws of the form</p><div>\[q_{,t} + Σ_{i=1,...d} F_{i,i} = s\]</div><p>where <span>$q$</span> is the state vector, <span>$F$</span> is the flux function, and <span>$s$</span> is the source function. <span>$F$</span> includes both the &quot;inviscid&quot; and &quot;viscous&quot; fluxes. Note that this is a space only discretization, time must be advanced using some ordinary differential equations methods; see <a href="@ref"><code>ODESolvers</code></a>.</p><p>The flux function <code>F_{i}</code> is taken to be of the form:</p><div>\[F_{i} := F_{i}(q, σ; a)\\
σ = H(q, ∇G(q; a); a)\]</div><p>where <span>$a$</span> is a set of parameters and viscous terms enter through <span>$σ$</span></p><p>The source term is of the form:</p><div>\[s := s(q; a)\]</div><p>In the code and docs the following terminology is used:</p><ul><li><span>$q$</span> is referred to as the state</li><li><span>$σ$</span> is the viscous state</li><li><span>$a$</span> is the auxiliary state</li><li><span>$F$</span> is the physical flux</li><li><span>$H$</span> is the viscous transform</li><li><span>$G$</span> is the gradient transform</li></ul><p>Much of the notation used in this module follows Hesthaven and Warburton (2008).</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Currently all the functions take the same parameters and the gradient transform can take a user-specified subset of the state vector.</p></div></div><div class="admonition references"><div class="admonition-title">References</div><div class="admonition-text"><pre><code class="language-none">@BOOK{HesthavenWarburton2008,
  title = {Nodal Discontinuous {G}alerkin Methods: {A}lgorithms, Analysis,
           and Applications},
  publisher = {Springer-Verlag New York},
  year = {2008},
  author = {Hesthaven, Jan S. and Warburton, Tim},
  volume = {54},
  series = {Texts in Applied Mathematics},
  doi = {10.1007/978-0-387-72067-8}
}</code></pre></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L1-L57">source</a></section><h3><a class="nav-anchor" id="Types-2" href="#Types-2">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw" href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DGBalanceLaw &lt;: AbstractDGMethod</code></pre><p>This contains the necessary information for a discontinuous Galerkin method for balance laws.</p><p>See also: Outer constructor <a href="DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a></p><p><strong>Fields</strong></p><ul><li><p><code>grid</code></p><p>computational grid / mesh</p></li><li><p><code>nstate</code></p><p>number of state</p></li><li><p><code>flux!</code></p><p>physical flux function</p></li><li><p><code>numerical_flux!</code></p><p>numerical flux function</p></li><li><p><code>numerical_boundary_flux!</code></p><p>numerical boundary flux function</p></li><li><p><code>Qvisc</code></p><p>storage for the viscous state</p></li><li><p><code>number_gradient_states</code></p><p>number of out states for gradient_transform!</p></li><li><p><code>number_viscous_states</code></p><p>number of out states for the viscous_transform!</p></li><li><p><code>gradient_transform!</code></p><p>transform from state to variables to take gradient of</p></li><li><p><code>viscous_transform!</code></p><p>transform from Q and gradient state to viscous states</p></li><li><p><code>viscous_penalty!</code></p><p>penalty for the viscous state computation</p></li><li><p><code>viscous_boundary_penalty!</code></p><p>boundary penalty for the viscous state computation (e.g., Dirichlet)</p></li><li><p><code>auxstate</code></p><p>auxiliary state array</p></li><li><p><code>source!</code></p><p>source function</p></li><li><p><code>preodefun!</code></p><p>callback function for before the <code>odefun!</code></p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L75-L87">source</a></section><h3><a class="nav-anchor" id="Constructor-1" href="#Constructor-1">Constructor</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}" href="#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw-Tuple{}"><code>CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">DGBalanceLaw(;grid::DiscontinuousSpectralElementGrid,
             length_state_vector,
             flux!,
             numerical_flux!,
             numerical_boundary_flux! = nothing,
             number_gradient_states = 0,
             number_viscous_states = 0,
             gradient_transform! = nothing,
             viscous_transform! = nothing,
             viscous_penalty! = nothing,
             viscous_boundary_penalty! = nothing,
             auxiliary_state_length = 0,
             auxiliary_state_initialization! = nothing,
             source! = nothing,
             preodefun! = nothing)</code></pre><p>Constructs a <code>DGBalanceLaw</code> spatial discretization type for the physics defined by <code>flux!</code> and <code>source!</code>. The computational domain is defined by <code>grid</code>. The number of state variables is defined by <code>length_state_vector</code>. The user may also specify an auxiliary state which will be unpacked by the compute kernel passed on to the user-defined flux and numerical flux functions. The source function <code>source!</code> is optional.</p><p>The flux function is called with data from a degree of freedom (DOF) as</p><pre><code class="language-none">flux!(F, Q, V, aux, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MArray</code> of size <code>(dim, length_state_vector)</code> to be filled (note that this is uninitialized so the user must set to zero if is this desired)</li><li><code>Q</code> is the state to evaluate (<code>MArray</code>)</li><li><code>V</code> is the viscous state to evaluate (<code>MArray</code>)</li><li><code>aux</code> is the user-defined auxiliary state (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>Warning: Modifications to <code>Q</code> or <code>aux</code> may cause side effects and should be avoided.</p><p>The numerical flux function is called with data from two DOFs as</p><pre><code class="language-none">numerical_flux!(F, nM, QM, VM, auxM, QP, VP, auxP, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MVector</code> of length <code>length_state_vector</code> to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero if is this desired)</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>)</li><li><code>VM</code> and <code>VP</code> are the minus and plus viscous side states (<code>MArray</code>)</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>Warning: Modifications to <code>nM</code>, <code>QM</code>, <code>auxM</code>, <code>QP</code>, or <code>auxP</code> may cause side effects and should be avoided.</p><p>If <code>grid.topology</code> has a boundary then the function <code>numerical_boundary_flux!</code> must be specified. This function is called with the data from the neighbouring DOF as</p><pre><code class="language-none">numerical_boundary_flux!(F, nM, QM, VM, auxM, QP, VP, auxP, bctype, t)</code></pre><p>where</p><ul><li><code>F</code> is an <code>MArray</code> of size <code>(dim, length_state_vector)</code> to be filled with the numerical flux across the face (note that this is uninitialized so user must set to zero is this desired)</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>)</li><li><code>VM</code> and <code>VP</code> are the minus and plus viscous side states (<code>MArray</code>)</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>bctype</code> is the boundary condition flag for the connected face and element of  <code>grid.elemtobndy</code></li><li><code>t</code> is the current simulation time</li></ul><p>Note: <code>QP</code> and <code>auxP</code> are filled with values based on degrees of freedom referenced in <code>grid.vmapP</code>; <code>QP</code> and <code>auxP</code> may be modified by the calling function.</p><p>Warning: Modifications to <code>nM</code>, <code>QM</code>, or <code>auxM</code> may cause side effects and should be avoided.</p><p>If present the source function is called with data from a DOF as</p><pre><code class="language-none">source!(S, Q, aux, t)</code></pre><p>where <code>S</code> is an <code>MVector</code> of length <code>length_state_vector</code> to be filled; other arguments are the same as <code>flux!</code> and the same warning concerning <code>Q</code> and <code>aux</code> applies.</p><p>When <code>auxiliary_state_initialization! !== nothing</code> then this is called on the auxiliary state (assuming <code>auxiliary_state_length &gt; 0</code>) as</p><pre><code class="language-none">auxiliary_state_initialization!(aux, x, y, z)</code></pre><p>where <code>aux</code> is an <code>MArray</code> to fill with the auxiliary state for a DOF located at Cartesian coordinate locations <code>(x, y, z)</code>; see also <a href="DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!"><code>grad_auxiliary_state!</code></a> allows the user to take the gradient of a field stored in the auxiliary state.</p><p>When viscous terms are needed, the user must specify values for the following keyword arguments:</p><ul><li><code>number_gradient_states</code> (<code>Int</code>)</li><li><code>number_viscous_states</code> (<code>Int</code>)</li><li><code>gradient_transform!</code> (<code>Function</code>)</li><li><code>viscous_transform!</code> (<code>Function</code>)</li><li><code>viscous_penalty!</code> (<code>Function</code>)</li><li><code>viscous_boundary_penalty!</code> (<code>Function</code>); only required if the topology has a boundary</li></ul><p>The function <code>gradient_transform!</code> is the implementation of the function <code>G</code> in the module docs; see <a href="DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations"><code>DGBalanceLawDiscretizations</code></a>.  It is called on each DOF as:</p><pre><code class="language-none">gradient_transform!(G, Q, aux, t)</code></pre><p>where <code>G</code> is an <code>MVector</code> of length <code>number_gradient_states</code> to be filled, <code>Q</code> is an <code>MVector</code> containing the states, <code>aux</code> is the full auxiliary state at the DOF, and <code>t</code> is the simulation time.Q</p><p>The function <code>viscous_transform!</code> is the implementation of the function <code>H</code> in the module docs; see <a href="DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations"><code>DGBalanceLawDiscretizations</code></a>. It transforms the gradient <span>$∇G$</span> and <span>$q$</span> into the viscous state <span>$σ$</span>. It is called on each DOF as:</p><pre><code class="language-none">viscous_transform!(V, gradG, Q, aux, t)</code></pre><p>where <code>V</code> is an <code>MVector</code> of length <code>number_viscous_states</code> to be filled, <code>gradG</code> is an <code>MMatrix</code> containing the DG-gradient of <span>$G$</span>, <code>Q</code> is an <code>MVector</code> containing the states, <code>aux</code> is the full auxiliary state at the DOF, and <code>t</code> is the simulation time. Note that <code>V</code> is a vector not a matrix so that minimal storage can be used if symmetry can be exploited.</p><p>The function <code>viscous_penalty!</code> is the penalty terms to be used for the DG-gradient calculation. It is called with data from two neighbouring degrees of freedom as</p><pre><code class="language-none">viscous_penalty!(V, nM, GM, QM, auxM, GP, QP, auxP, t)</code></pre><p>where:</p><ul><li><code>V</code> is an <code>MVector</code> of length <code>number_viscous_states</code> to be filled with the numerical penalty across the face; see below.</li><li><code>nM</code> is the unit outward normal to the face with respect to the minus side (<code>MVector</code> of length <code>3</code>)</li><li><code>GM</code> and <code>GP</code> are the minus and plus evaluation of <code>gradient_transform!</code> on either side of the face</li><li><code>QM</code> and <code>QP</code> are the minus and plus side states (<code>MArray</code>)</li><li><code>auxM</code> and <code>auxP</code> are the auxiliary states (<code>MArray</code>)</li><li><code>t</code> is the current simulation time</li></ul><p>The viscous penalty function should compute on the faces</p><div>\[n^{-} \cdot H^{*} - n^{-} \cdot H^{-}\]</div><p>where <span>$n^{-} \cdot H^{*}$</span> is the &quot;numerical-flux&quot; for the viscous state computation and <span>$H^{-}$</span> is the value of <code>viscous_transform!</code> evaluated on the minus side with <span>$n^{-} \cdot G^{-}$</span> as an argument.</p><p>If <code>grid.topology</code> has a boundary then the function <code>viscous_boundary_penalty!</code> must be specified. This function is called with the data from the neighbouring DOF as</p><pre><code class="language-none">viscous_boundary_penalty!(V, nM, GM, QM, auxM, GP, QP, auxP, bctype, t)</code></pre><p>where the required behaviour mimics that of <code>viscous_penalty!</code> and <code>numerical_boundary_flux!</code>.</p><p>If <code>preodefun!</code> is called right before the rest of the ODE function, with the main purpose to allow the user to populate/modify the auxiliary state <code>disc.auxstate</code> to be consistent with the current time <code>t</code> and solution vector <code>Q</code></p><pre><code class="language-none">preodefun!(disc, Q, t)</code></pre><p>where <code>disc</code> is the <code>DGBalanceLaw</code> structure and <code>Q</code> is the current state being used to evaluate the ODE function.</p><div class="admonition note"><div class="admonition-title">notes on `preodefun!`</div><div class="admonition-text"><p>Unlike the other callbacks, this function is not called at the device (or kernel) level but the host level.</p><p>MPI communication of <code>Q</code> occurs after the <code>odefun!</code> and no MPI communication of <code>auxstate</code> is performed (if this is needed we will need to determine a way to handle it in order to overlap communication and computation as well only comm update fields).</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>If <code>(x, y, z)</code>, or data derived from this such as spherical coordinates, is needed in the flux or source the user is responsible to storing this in the auxiliary state</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L135-L325">source</a></section><h3><a class="nav-anchor" id="Functions-2" href="#Functions-2">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!" href="#CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!"><code>CLIMA.DGBalanceLawDiscretizations.grad_auxiliary_state!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">grad_auxiliary_state!(disc, i, (ix, iy, iz))</code></pre><p>Computes the gradient of a the field <code>i</code> of the constant auxiliary state of <code>disc</code> and stores the <code>x, y, z</code> compoment in fields <code>ix, iy, iz</code> of constant auxiliary state.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>This only computes the element gradient not a DG gradient. If your constant auxiliary state is discontinuous this may or may not be what you want!</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L643-L654">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.indefinite_stack_integral!" href="#CLIMA.DGBalanceLawDiscretizations.indefinite_stack_integral!"><code>CLIMA.DGBalanceLawDiscretizations.indefinite_stack_integral!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">indefinite_stack_integral!(disc, f, Q, out_states, [P=disc.auxstate])</code></pre><p>Computes an indefinite line integral along the trailing dimension (<code>zeta</code> in 3-D and <code>η</code> in 2-D) up an element stack using state <code>Q</code></p><div>\[∫_{ζ_{0}}^{ζ} f(q; aux, t)\]</div><p>and stores the result of the integral in field of <code>P</code> indicated by <code>out_states</code></p><p>The syntax of the integral kernel is:</p><pre><code class="language-none">f(F, Q, aux)</code></pre><p>where <code>F</code> is an <code>MVector</code> of length <code>length(out_states)</code>, <code>Q</code> and <code>aux</code> are the <code>MVectors</code> for the state and auxiliary state at a single degree of freedom. The function is responsible for filling <code>F</code>.</p><p>Requires the <code>isstacked(disc.grid.topology) == true</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L686-L706">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.reverse_indefinite_stack_integral!" href="#CLIMA.DGBalanceLawDiscretizations.reverse_indefinite_stack_integral!"><code>CLIMA.DGBalanceLawDiscretizations.reverse_indefinite_stack_integral!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reverse_indefinite_stack_integral!(disc, oustate, instate,
                                   [P=disc.auxstate])</code></pre><p>reverse previously computed indefinite integral(s) computed with <code>indefinite_stack_integral!</code> to be</p><div>\[∫_{ζ}^{ζ_{max}} f(q; aux, t)\]</div><p>The states <code>instate[i]</code> is reverse and stored in <code>instate[i]</code>.</p><p>Requires the <code>isstacked(disc.grid.topology) == true</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L739-L752">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.dof_iteration!" href="#CLIMA.DGBalanceLawDiscretizations.dof_iteration!"><code>CLIMA.DGBalanceLawDiscretizations.dof_iteration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">dof_iteration!(dof_fun!::Function, R::MPIStateArray, disc::DGBalanceLaw,
               Q::MPIStateArray)</code></pre><p>Iterate over each dof to fill <code>R</code> using the <code>dof_fun!</code>. The syntax of the <code>dof_fun!</code> is</p><pre><code class="language-none">dof_fun!(l_R, l_Q, l_Qvisc, l_aux)</code></pre><p>where <code>l_R</code>, <code>l_Q</code>, <code>l_Qvisc</code>, and <code>l_aux</code> are of type <code>MArray</code> filled initially with the values at a single degree of freedom. After the call the values in <code>l_R</code> will be written back to the degree of freedom of <code>R</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L780-L792">source</a></section><h3><a class="nav-anchor" id="Pirated-Type-Functions-1" href="#Pirated-Type-Functions-1">Pirated Type Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}" href="#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw}"><code>CLIMA.MPIStateArrays.MPIStateArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MPIStateArray(disc::DGBalanceLaw; nstate=disc.nstate, commtag=888)</code></pre><p>Given a discretization <code>disc</code> constructs an <code>MPIStateArrays</code> for holding a solution state. The optional &#39;nstate&#39; arguments allows the user to specify a specific number of states. The optional <code>commtag</code> allows the user to set the tag to use for communication with this <code>MPIStateArray</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L419-L426">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}" href="#CLIMA.MPIStateArrays.MPIStateArray-Tuple{CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw,Function}"><code>CLIMA.MPIStateArrays.MPIStateArray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">MPIStateArray(disc::DGBalanceLaw, initialization!::Function; commtag=888)</code></pre><p>Given a discretization <code>disc</code> constructs an <code>MPIStateArrays</code> for holding a solution state. The optional <code>commtag</code> allows the user to set the tag to use for communication with this <code>MPIStateArray</code>.</p><p>After allocation the <code>MPIStateArray</code> is initialized using the function <code>initialization!</code> which will be called as:</p><pre><code class="language-none">initialization!(Q, x, y, z, aux)</code></pre><p>where <code>Q</code> is an <code>MArray</code> with the solution state at a single degree of freedom (DOF) to initialize and <code>(x,y,z)</code> is the coordinate point for the allocation. The auxiliary data the values at the DOF are passed through as an <code>MArray</code> through the <code>aux</code> argument; if <code>disc</code> does not have auxiliary data then the length of the <code>MArray</code> will be zero.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><code>Q</code> is <code>undef</code> at start the function (i.e., not initialized to zero)</p></div></div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Modifications of the <code>aux</code> array will be discarded.</p></div></div><div class="admonition todo"><div class="admonition-title">Todo</div><div class="admonition-text"><p>Remove <code>host</code> and <code>device</code> data transfers.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations.jl#L452-L482">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>CLIMA.SpaceMethods.odefun!(::DGBalanceLawDiscretizations.DGBalanceLaw, dQ, Q, t)</code>. Check Documenter&#39;s build log for details.</p></div></div><h3><a class="nav-anchor" id="Kernels-1" href="#Kernels-1">Kernels</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.volumerhs!" href="#CLIMA.DGBalanceLawDiscretizations.volumerhs!"><code>CLIMA.DGBalanceLawDiscretizations.volumerhs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">volumerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{nviscstate},
           ::Val{nauxstate}, flux!, source!, rhs, Q, Qvisc, auxstate,
           vgeo, t, D, elems) where {dim, N, nstate, nviscstate,</code></pre><p>Computational kernel: Evaluate the volume integrals on right-hand side of a <code>DGBalanceLaw</code> semi-discretization.</p><p>See <a href="DGmethods_old.html#CLIMA.SpaceMethods.odefun!"><code>odefun!</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations_kernels.jl#L18-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.facerhs!" href="#CLIMA.DGBalanceLawDiscretizations.facerhs!"><code>CLIMA.DGBalanceLawDiscretizations.facerhs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">facerhs!(::Val{dim}, ::Val{N}, ::Val{nstate}, ::Val{nviscstate},
         ::Val{nauxstate}, numerical_flux!,
         numerical_boundary_flux!, rhs, Q, Qvisc, auxstate,
         vgeo, sgeo, t, vmapM, vmapP, elemtobndy,
         elems) where {dim, N, nstate, nviscstate, nauxstate}</code></pre><p>Computational kernel: Evaluate the surface integrals on right-hand side of a <code>DGBalanceLaw</code> semi-discretization.</p><p>See <a href="DGmethods_old.html#CLIMA.SpaceMethods.odefun!"><code>odefun!</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations_kernels.jl#L216-L227">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DGBalanceLawDiscretizations.volumeviscterms!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DGBalanceLawDiscretizations.faceviscterms!</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.initauxstate!" href="#CLIMA.DGBalanceLawDiscretizations.initauxstate!"><code>CLIMA.DGBalanceLawDiscretizations.initauxstate!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">initauxstate!(::Val{dim}, ::Val{N}, ::Val{nauxstate}, auxstatefun!,
              auxstate, vgeo, elems) where {dim, N, nauxstate}</code></pre><p>Computational kernel: Initialize the auxiliary state</p><p>See <a href="DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations_kernels.jl#L530-L537">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DGBalanceLawDiscretizations.initauxstate!</code>. Check Documenter&#39;s build log for details.</p></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.elem_grad_field!" href="#CLIMA.DGBalanceLawDiscretizations.elem_grad_field!"><code>CLIMA.DGBalanceLawDiscretizations.elem_grad_field!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">elem_grad_field!(::Val{dim}, ::Val{N}, ::Val{nstate}, Q, vgeo, D, elems, s,
                 sx, sy, sz) where {dim, N, nstate}</code></pre><p>Computational kernel: Compute the element gradient of state <code>s</code> of <code>Q</code> and store it in <code>sx</code>, <code>sy</code>, and <code>sz</code> of <code>Q</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>This does not compute a DG gradient, but only over the element. If <span>$Q_s$</span> is discontinuous you may want to consider another approach.</p></div></div></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations_kernels.jl#L565-L577">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.knl_dof_iteration!" href="#CLIMA.DGBalanceLawDiscretizations.knl_dof_iteration!"><code>CLIMA.DGBalanceLawDiscretizations.knl_dof_iteration!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">knl_dof_iteration!(::Val{dim}, ::Val{N}, ::Val{nRstate}, ::Val{nstate},
                   ::Val{nviscstate}, ::Val{nauxstate}, dof_fun!, R, Q,
                   QV, auxstate, elems) where {dim, N, nRstate, nstate,
                                               nviscstate, nauxstate}</code></pre><p>Computational kernel: fill postprocessing array</p><p>See <a href="DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations_kernels.jl#L706-L715">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.DGBalanceLawDiscretizations.knl_indefinite_stack_integral!" href="#CLIMA.DGBalanceLawDiscretizations.knl_indefinite_stack_integral!"><code>CLIMA.DGBalanceLawDiscretizations.knl_indefinite_stack_integral!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">knl_indefinite_stack_integral!(::Val{dim}, ::Val{N}, ::Val{nstate},
                                        ::Val{nauxstate}, ::Val{nvertelem},
                                        int_knl!, Q, auxstate, vgeo, Imat,
                                        elems, ::Val{outstate}
                                       ) where {dim, N, nstate, nauxstate,
                                                outstate, nvertelem}</code></pre><p>Computational kernel: compute indefinite integral along the vertical stack</p><p>See <a href="DGmethods_old.html#CLIMA.DGBalanceLawDiscretizations.DGBalanceLaw"><code>DGBalanceLaw</code></a> for usage.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/9b16496c87cb9e015dc59de88443a0b4899aaf6a/src/DGmethods_old/DGBalanceLawDiscretizations_kernels.jl#L760-L771">source</a></section><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DGBalanceLawDiscretizations.knl_reverse_indefinite_stack_integral!</code>. Check Documenter&#39;s build log for details.</p></div></div><h2><a class="nav-anchor" id="DGBalanceLawDiscretizations.NumericalFluxes_old-1" href="#DGBalanceLawDiscretizations.NumericalFluxes_old-1"><code>DGBalanceLawDiscretizations.NumericalFluxes_old</code></a></h2><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DGBalanceLawDiscretizations.NumericalFluxes_old.rusanov!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>DGBalanceLawDiscretizations.NumericalFluxes_old.rusanov_boundary_flux!</code>. Check Documenter&#39;s build log for details.</p></div></div><footer><hr/><a class="previous" href="Arrays.html"><span class="direction">Previous</span><span class="title">Arrays</span></a><a class="next" href="InputOutput.html"><span class="direction">Next</span><span class="title">InputOutput</span></a></footer></article></body></html>
