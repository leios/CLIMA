<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh · CLIMA</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="CLIMA logo"/></a><h1>CLIMA</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><span class="toctext">Common</span><ul><li><a class="toctext" href="Common/MoistThermodynamics.html">MoistThermodynamics</a></li></ul></li><li><span class="toctext">Utilites</span><ul><li><a class="toctext" href="Utilities/RootSolvers.html">RootSolvers</a></li></ul></li><li><span class="toctext">Atmos</span><ul><li><a class="toctext" href="Atmos/SurfaceFluxes.html"><code>SurfaceFluxes</code></a></li><li><a class="toctext" href="Atmos/TurbulenceConvection.html"><code>TurbulenceConvection</code></a></li><li><a class="toctext" href="Atmos/EDMFEquations.html">Eddy-Diffusivity Mass-Flux (EDMF) equations</a></li><li><a class="toctext" href="Atmos/Microphysics.html">Microphysics</a></li></ul></li><li><a class="toctext" href="ODESolvers.html">ODESolvers</a></li><li><a class="toctext" href="LinearSolvers.html">LinearSolvers</a></li><li class="current"><a class="toctext" href="Mesh.html">Mesh</a><ul class="internal"><li><a class="toctext" href="#Topologies-1"><code>Topologies</code></a></li><li><a class="toctext" href="#Grids-1"><code>Grids</code></a></li><li><a class="toctext" href="#Filters-1"><code>Filters</code></a></li></ul></li><li><a class="toctext" href="Arrays.html">Arrays</a></li><li><a class="toctext" href="DGmethods_old.html">DGmethods_old</a></li><li><a class="toctext" href="InputOutput.html">InputOutput</a></li><li><span class="toctext">Developer docs</span><ul><li><a class="toctext" href="CodingConventions.html">Coding Conventions</a></li><li><a class="toctext" href="AcceptableUnicode.html">Acceptable Unicode characters</a></li><li><a class="toctext" href="VariableList.html">CliMA Variable List</a></li></ul></li><li><span class="toctext">Balance Law Examples</span><ul><li><a class="toctext" href="BalanceLawOverview.html">DG Balance Law Method</a></li><li><a class="toctext" href="examples/DGmethods_old/generated/ex_001_periodic_advection.html">Example 001: Periodic Advection</a></li><li><a class="toctext" href="examples/DGmethods_old/generated/ex_002_solid_body_rotation.html">Example 002: Solid Body Rotation</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="Mesh.html">Mesh</a></li></ul><a class="edit-page" href="https://github.com/climate-machine/CLIMA/blob/master/docs/src/Mesh.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Mesh</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Meshing-Stuff-1" href="#Meshing-Stuff-1">Meshing Stuff</a></h1><h2><a class="nav-anchor" id="Topologies-1" href="#Topologies-1"><code>Topologies</code></a></h2><p>Topologies encode the connectivity of the elements, spatial domain interval and MPI communication.</p><h3><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.AbstractTopology" href="#CLIMA.Mesh.Topologies.AbstractTopology"><code>CLIMA.Mesh.Topologies.AbstractTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractTopology{dim}</code></pre><p>Represents the connectivity of individual elements, with local dimension <code>dim</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L11-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.BoxElementTopology" href="#CLIMA.Mesh.Topologies.BoxElementTopology"><code>CLIMA.Mesh.Topologies.BoxElementTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BoxElementTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>The local topology of a larger MPI-distributed topology, represented by <code>dim</code>-dimensional box elements.</p><p>This contains the necessary information for the connectivity elements of the elements on the local process, along with &quot;ghost&quot; elements from neighbouring processes.</p><p><strong>Fields</strong></p><ul><li><p><code>mpicomm</code></p><p>MPI communicator for communicating with neighbouring processes.</p></li></ul><ul><li><p><code>elems</code></p><p>Range of element indices</p></li></ul><ul><li><p><code>realelems</code></p><p>Range of real (aka nonghost) element indices</p></li></ul><ul><li><p><code>ghostelems</code></p><p>Range of ghost element indices</p></li></ul><ul><li><p><code>ghostfaces</code></p><p>Ghost element to face is received; <code>ghostfaces[f,ge] == true</code> if face <code>f</code> of ghost element <code>ge</code> is received.</p></li></ul><ul><li><p><code>sendelems</code></p><p>Array of send element indices</p></li></ul><ul><li><p><code>sendfaces</code></p><p>Send element to face is sent; <code>sendfaces[f,se] == true</code> if face <code>f</code> of send element <code>se</code> is sent.</p></li></ul><ul><li><p><code>elemtocoord</code></p><p>Element to vertex coordinates; <code>elemtocoord[d,i,e]</code> is the <code>d</code>th coordinate of corner <code>i</code> of element <code>e</code></p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>currently coordinates always are of size 3 for <code>(x1, x2, x3)</code></p></div></div></li></ul><ul><li><p><code>elemtoelem</code></p><p>Element to neighboring element; <code>elemtoelem[f,e]</code> is the number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoelem[f,e] == e</code>.</p></li></ul><ul><li><p><code>elemtoface</code></p><p>Element to neighboring element face; <code>elemtoface[f,e]</code> is the face number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoface[f,e] == f</code>.&quot;</p></li></ul><ul><li><p><code>elemtoordr</code></p><p>element to neighboring element order; <code>elemtoordr[f,e]</code> is the ordering number of the element neighboring element <code>e</code> across face <code>f</code>.  If there is no neighboring element then <code>elemtoordr[f,e] == 1</code>.</p></li></ul><ul><li><p><code>elemtobndy</code></p><p>Element to bounday number; <code>elemtobndy[f,e]</code> is the boundary number of face <code>f</code> of element <code>e</code>.  If there is a neighboring element then <code>elemtobndy[f,e] == 0</code>.</p></li></ul><ul><li><p><code>nabrtorank</code></p><p>List of the MPI ranks for the neighboring processes</p></li></ul><ul><li><p><code>nabrtorecv</code></p><p>Range in ghost elements to receive for each neighbor</p></li></ul><ul><li><p><code>nabrtosend</code></p><p>Range in <code>sendelems</code> to send for each neighbor</p></li></ul><ul><li><p><code>hasboundary</code></p><p>boolean for whether or not this topology has a boundary</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L18-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.BrickTopology" href="#CLIMA.Mesh.Topologies.BrickTopology"><code>CLIMA.Mesh.Topologies.BrickTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BrickTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>A simple grid-based topology. This is a convenience wrapper around <a href="Mesh.html#CLIMA.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L144-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.StackedBrickTopology" href="#CLIMA.Mesh.Topologies.StackedBrickTopology"><code>CLIMA.Mesh.Topologies.StackedBrickTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StackedBrickTopology{dim, T} &lt;: AbstractTopology{dim}</code></pre><p>A simple grid-based topology, where all elements on the trailing dimension are stacked to be contiguous. This is a convenience wrapper around <a href="Mesh.html#CLIMA.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L169-L175">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.CubedShellTopology" href="#CLIMA.Mesh.Topologies.CubedShellTopology"><code>CLIMA.Mesh.Topologies.CubedShellTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CubedShellTopology{T} &lt;: AbstractTopology{2}</code></pre><p>A cube-shell topology. This is a convenience wrapper around <a href="Mesh.html#CLIMA.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L156-L161">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.StackedCubedSphereTopology" href="#CLIMA.Mesh.Topologies.StackedCubedSphereTopology"><code>CLIMA.Mesh.Topologies.StackedCubedSphereTopology</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">StackedCubedSphereTopology{3, T} &lt;: AbstractTopology{3}</code></pre><p>A cube-sphere topology. All elements on the same &quot;vertical&quot; dimension are stacked to be contiguous. This is a convenience wrapper around <a href="Mesh.html#CLIMA.Mesh.Topologies.BoxElementTopology"><code>BoxElementTopology</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L185-L191">source</a></section><h3><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.BrickTopology-Tuple{Any,Any}" href="#CLIMA.Mesh.Topologies.BrickTopology-Tuple{Any,Any}"><code>CLIMA.Mesh.Topologies.BrickTopology</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">BrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)</code></pre><p>Generate a brick mesh topology with coordinates given by the tuple <code>elemrange</code> and the periodic dimensions given by the <code>periodicity</code> tuple.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x2$</span>-direction with</p><pre><code class="language-julia">
using CLIMA.Topologies
using MPI
MPI.Init()
topology = BrickTopology(MPI.COMM_SELF, (2:5,4:6);
                         periodicity=(false,true),
                         boundary=((1,2),(3,4)))</code></pre><p>This returns the mesh structure for</p><pre><code class="language-none">         x2

          ^
          |
         6-  +-----+-----+-----+
          |  |     |     |     |
          |  |  3  |  4  |  5  |
          |  |     |     |     |
         5-  +-----+-----+-----+
          |  |     |     |     |
          |  |  1  |  2  |  6  |
          |  |     |     |     |
         4-  +-----+-----+-----+
          |
          +--|-----|-----|-----|--&gt; x1
             2     3     4     5</code></pre><p>For example, the (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtocoord
2×4×6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 3  4  3  4
 4  4  5  5

[:, :, 3] =
 2  3  2  3
 5  5  6  6

[:, :, 4] =
 3  4  3  4
 5  5  6  6

[:, :, 5] =
 4  5  4  5
 5  5  6  6

[:, :, 6] =
 4  5  4  5
 4  4  5  5</code></pre><p>Note that the corners are listed in Cartesian order.</p><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtobndy
4×6 Array{Int64,2}:
 1  0  1  0  0  0
 0  0  0  0  2  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L205-L295">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}" href="#CLIMA.Mesh.Topologies.StackedBrickTopology-Tuple{Any,Any}"><code>CLIMA.Mesh.Topologies.StackedBrickTopology</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">StackedBrickTopology{dim, T}(mpicomm, elemrange; boundary, periodicity)</code></pre><p>Generate a stacked brick mesh topology with coordinates given by the tuple <code>elemrange</code> and the periodic dimensions given by the <code>periodicity</code> tuple.</p><p>The elements are stacked such that the elements associated with range <code>elemrange[dim]</code> are contiguous in the element ordering.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve.  Further, stacks are not split at MPI boundaries.</p><p>By default boundary faces will be marked with a one and other faces with a zero.  Specific boundary numbers can also be passed for each face of the brick in <code>boundary</code>.  This will mark the nonperiodic brick faces with the given boundary number.</p><p><strong>Examples</strong></p><p>We can build a 3 by 2 element two-dimensional mesh that is periodic in the <span>$x2$</span>-direction with</p><pre><code class="language-julia">
using CLIMA.Topologies
using MPI
MPI.Init()
topology = StackedBrickTopology(MPI.COMM_SELF, (2:5,4:6);
                                periodicity=(false,true),
                                boundary=((1,2),(3,4)))</code></pre><p>This returns the mesh structure stacked in the <span>$x2$</span>-direction for</p><pre><code class="language-none">         x2

          ^
          |
         6-  +-----+-----+-----+
          |  |     |     |     |
          |  |  2  |  4  |  6  |
          |  |     |     |     |
         5-  +-----+-----+-----+
          |  |     |     |     |
          |  |  1  |  3  |  5  |
          |  |     |     |     |
         4-  +-----+-----+-----+
          |
          +--|-----|-----|-----|--&gt; x1
             2     3     4     5</code></pre><p>For example, the (dimension by number of corners by number of elements) array <code>elemtocoord</code> gives the coordinates of the corners of each element.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtocoord
2×4×6 Array{Int64,3}:
[:, :, 1] =
 2  3  2  3
 4  4  5  5

[:, :, 2] =
 2  3  2  3
 5  5  6  6

[:, :, 3] =
 3  4  3  4
 4  4  5  5

[:, :, 4] =
 3  4  3  4
 5  5  6  6

[:, :, 5] =
 4  5  4  5
 4  4  5  5

[:, :, 6] =
 4  5  4  5
 5  5  6  6</code></pre><p>Note that the corners are listed in Cartesian order.</p><p>The (number of faces by number of elements) array <code>elemtobndy</code> gives the boundary number for each face of each element.  A zero will be given for connected faces.</p><pre><code class="language-julia-repl">julia&gt; topology.elemtobndy
4×6 Array{Int64,2}:
 1  0  1  0  0  0
 0  0  0  0  2  2
 0  0  0  0  0  0
 0  0  0  0  0  0</code></pre><p>Note that the faces are listed in Cartesian order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L331-L423">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}" href="#CLIMA.Mesh.Topologies.CubedShellTopology-Tuple{Any,Any,Any}"><code>CLIMA.Mesh.Topologies.CubedShellTopology</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">CubedShellTopology(mpicomm, Nelem, T) &lt;: AbstractTopology{dim}</code></pre><p>Generate a cubed shell mesh with the number of elements along each dimension of the cubes being <code>Nelem</code>. This topology actual creates a cube mesh, and the warping should be done after the grid is created using the <code>cubedshellwarp</code> function. The coordinates of the points will be of type <code>T</code>.</p><p>The elements of the shell are partitioned equally across the MPI ranks based on a space-filling curve.</p><p>Note that this topology is logically 2-D but embedded in a 3-D space</p><p><strong>Examples</strong></p><p>We can build a cubed shell mesh with 10 elements on each cube, total elements is <code>10 * 10 * 6 = 600</code>, with</p><pre><code class="language-julia">using CLIMA.Topologies
using MPI
MPI.Init()
topology = CubedShellTopology(MPI.COMM_SELF, 10, Float64)

# Typically the warping would be done after the grid is created, but the cell
# corners could be warped with...

# Shell radius = 1
x1, x2, x3 = ntuple(j-&gt;topology.elemtocoord[j, :, :], 3)
for n = 1:length(x1)
   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])
end

# Shell radius = 10
x1, x2, x3 = ntuple(j-&gt;topology.elemtocoord[j, :, :], 3)
for n = 1:length(x1)
  x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n], 10)
end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L591-L629">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}" href="#CLIMA.Mesh.Topologies.StackedCubedSphereTopology-Tuple{Any,Any,Any}"><code>CLIMA.Mesh.Topologies.StackedCubedSphereTopology</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>StackedCubedSphereTopology(mpicomm, Nhorz, Rrange;                               boundary=(1,1)) &lt;: AbstractTopology{3}</p><p>Generate a stacked cubed sphere topology with <code>Nhorz</code> by <code>Nhorz</code> cells for each horizontal face and <code>Rrange</code> is the radius edges of the stacked elements.  This topology actual creates a cube mesh, and the warping should be done after the grid is created using the <code>cubedshellwarp</code> function. The coordinates of the points will be of type <code>eltype(Rrange)</code>. The inner boundary condition type is <code>boundary[1]</code> and the outer boundary condition type is <code>boundary[2]</code>.</p><p>The elements are stacked such that the vertical elements are contiguous in the element ordering.</p><p>The elements of the brick are partitioned equally across the MPI ranks based on a space-filling curve. Further, stacks are not split at MPI boundaries.</p><p><strong>Examples</strong></p><p>We can build a cubed sphere mesh with 10 x 10 x 5 elements on each cube, total elements is <code>10 * 10 * 5 * 6 = 3000</code>, with</p><pre><code class="language-julia">using CLIMA.Topologies
using MPI
MPI.Init()
Nhorz = 10
Nstack = 5
Rrange = Float64.(accumulate(+,1:Nstack+1))
topology = StackedCubedSphereTopology(MPI.COMM_SELF, Nhorz, Rrange)

x1, x2, x3 = ntuple(j-&gt;reshape(topology.elemtocoord[j, :, :],
                            2, 2, 2, length(topology.elems)), 3)
for n = 1:length(x1)
   x1[n], x2[n], x3[n] = Topologies.cubedshellwarp(x1[n], x2[n], x3[n])
end</code></pre><p>Note that the faces are listed in Cartesian order.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L828-L865">source</a></section><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.cubedshellmesh" href="#CLIMA.Mesh.Topologies.cubedshellmesh"><code>CLIMA.Mesh.Topologies.cubedshellmesh</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cubedshellmesh(T, Ne; part=1, numparts=1)</code></pre><p>Generate a cubed mesh with each of the &quot;cubes&quot; has an <code>Ne X Ne</code> grid of elements.</p><p>The mesh can optionally be partitioned into <code>numparts</code> and this returns partition <code>part</code>.  This is a simple Cartesian partition and further partitioning (e.g, based on a space-filling curve) should be done before the mesh is used for computation.</p><p>This mesh returns the cubed spehere in a flatten fashion for the vertex values, and a remapping is needed to embed the mesh in a 3-D space.</p><p>The mesh structures for the cubes is as follows:</p><pre><code class="language-none">x2
   ^
   |
4Ne-           +-------+
   |           |       |
   |           |   6   |
   |           |       |
3Ne-           +-------+
   |           |       |
   |           |   5   |
   |           |       |
2Ne-           +-------+
   |           |       |
   |           |   4   |
   |           |       |
 Ne-   +-------+-------+-------+
   |   |       |       |       |
   |   |   1   |   2   |   3   |
   |   |       |       |       |
  0-   +-------+-------+-------+
   |
   +---|-------|-------|------|-&gt; x1
       0      Ne      2Ne    3Ne</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L669-L711">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.cubedshellwarp" href="#CLIMA.Mesh.Topologies.cubedshellwarp"><code>CLIMA.Mesh.Topologies.cubedshellwarp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">cubedshellwarp(a, b, c, R = max(abs(a), abs(b), abs(c)))</code></pre><p>Given points <code>(a, b, c)</code> on the surface of a cube, warp the points out to a spherical shell of radius <code>R</code> based on the equiangular gnomonic grid proposed by Ronchi, Iacono, Paolucci (1996) <a href="https://dx.doi.org/10.1006/jcph.1996.0047">https://dx.doi.org/10.1006/jcph.1996.0047</a></p><pre><code class="language-none">@article{RonchiIaconoPaolucci1996,
  title={The ``cubed sphere&#39;&#39;: a new method for the solution of partial
         differential equations in spherical geometry},
  author={Ronchi, C. and Iacono, R. and Paolucci, P. S.},
  journal={Journal of Computational Physics},
  volume={124},
  number={1},
  pages={93--114},
  year={1996},
  doi={10.1006/jcph.1996.0047}
}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L771-L792">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Topologies.hasboundary" href="#CLIMA.Mesh.Topologies.hasboundary"><code>CLIMA.Mesh.Topologies.hasboundary</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">hasboundary(topology::AbstractTopology)</code></pre><p>query function to check whether a topology has a boundary (i.e., not fully periodic)</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Topologies.jl#L129-L134">source</a></section><h2><a class="nav-anchor" id="Grids-1" href="#Grids-1"><code>Grids</code></a></h2><p>Grids specify the approximation within each element, and any necessary warping.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Grids.DiscontinuousSpectralElementGrid" href="#CLIMA.Mesh.Grids.DiscontinuousSpectralElementGrid"><code>CLIMA.Mesh.Grids.DiscontinuousSpectralElementGrid</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DiscontinuousSpectralElementGrid(topology; FloatType, DeviceArray,
                                 polynomialorder,
                                 meshwarp = (x...)-&gt;identity(x))</code></pre><p>Generate a discontinuous spectral element (tensor product, Legendre-Gauss-Lobatto) grid/mesh from a <code>topology</code>, where the order of the elements is given by <code>polynomialorder</code>. <code>DeviceArray</code> gives the array type used to store the data (<code>CuArray</code> or <code>Array</code>), and the coordinate points will be of <code>FloatType</code>.</p><p>The optional <code>meshwarp</code> function allows the coordinate points to be warped after the mesh is created; the mesh degrees of freedom are orginally assigned using a trilinear blend of the element corner locations.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Grids.jl#L51-L65">source</a></section><h2><a class="nav-anchor" id="Filters-1" href="#Filters-1"><code>Filters</code></a></h2><p>There are methods used to cleanup state vectors.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Filters.CutoffFilter" href="#CLIMA.Mesh.Filters.CutoffFilter"><code>CLIMA.Mesh.Filters.CutoffFilter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CutoffFilter(grid, Nc=polynomialorder(grid))</code></pre><p>Returns the spectral filter that zeros out polynomial modes greater than or equal to <code>Nc</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Filters.jl#L73-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Filters.ExponentialFilter" href="#CLIMA.Mesh.Filters.ExponentialFilter"><code>CLIMA.Mesh.Filters.ExponentialFilter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExponentialFilter(grid, Nc=0, s=32, α=-log(eps(eltype(grid))))</code></pre><p>Returns the spectral filter with the filter function</p><div>\[σ(η) = xp(-α η^s)\]</div><p>where <code>s</code> is the filter order (must be even), the filter starts with polynomial order <code>Nc</code>, and <code>alpha</code> is a parameter controlling the smallest value of the filter function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Filters.jl#L42-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CLIMA.Mesh.Filters.TMARFilter" href="#CLIMA.Mesh.Filters.TMARFilter"><code>CLIMA.Mesh.Filters.TMARFilter</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TMARFilter()</code></pre><p>Returns the truncation and mass aware rescaling nonnegativity preservation filter.  The details of this filter are described in</p><pre><code class="language-none">@article{doi:10.1175/MWR-D-16-0220.1,
  author = {Light, Devin and Durran, Dale},
  title = {Preserving Nonnegativity in Discontinuous Galerkin
           Approximations to Scalar Transport via Truncation and Mass
           Aware Rescaling (TMAR)},
  journal = {Monthly Weather Review},
  volume = {144},
  number = {12},
  pages = {4771-4786},
  year = {2016},
  doi = {10.1175/MWR-D-16-0220.1},
}</code></pre><p>Note this needs to be used with a restrictive time step or a flux correction to ensure that grid integral is conserved.</p><p><strong>Examples</strong></p><p>This filter can be applied to the 3rd and 4th fields of an <code>MPIStateArray</code> <code>Q</code> with the code</p><pre><code class="language-julia">Filters.apply!(Q, (3, 4), grid, TMARFilter())</code></pre><p>where <code>grid</code> is the associated <code>DiscontinuousSpectralElementGrid</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/climate-machine/CLIMA/blob/127caf846d846cf1cd765766fc3a9aed67df10f0/src/Mesh/Filters.jl#L94-L126">source</a></section><footer><hr/><a class="previous" href="LinearSolvers.html"><span class="direction">Previous</span><span class="title">LinearSolvers</span></a><a class="next" href="Arrays.html"><span class="direction">Next</span><span class="title">Arrays</span></a></footer></article></body></html>
